# Diff Log

> Auto-generated by ForgeGuard Upgrade IDE — 2026-02-18 17:13:28 UTC
> Repository: `HAAIL-Universe/ForgeGuard`

## Changes (15 file(s))

### 1. `.github/workflows/ci.yml` — create

Create GitHub Actions CI workflow with parallel backend (pytest) and frontend (vitest) jobs. Backend job sets FORGE_SANDBOX=1 and filters out integration-marked tests. Frontend job runs vitest in the web/ subdirectory.

**After:**
```yml
name: CI

on:
  push:
    branches: [main]
  pull_request:

jobs:
  backend-tests:
    runs-on: ubuntu-latest
    env:
      FORGE_SANDBOX: "1"
      CI: "1"
      TESTING: "1"
      DATABASE_URL: "sqlite:///:memory:"
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Run backend tests
        run: pytest -v -m "not integration" --tb=short

  frontend-tests:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: web
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm ci

      - name: Run frontend tests
        run: npm test

```

### 2. `README.md` — modify

Add CI status badge immediately after the main heading, linking to the GitHub Actions workflow runs page.

**Before:**
```md
# ForgeGuard

**AI-powered repository governance platform.**
```

**After:**
```md
# ForgeGuard

[![CI](https://github.com/HAAIL-Universe/ForgeGuard/actions/workflows/ci.yml/badge.svg)](https://github.com/HAAIL-Universe/ForgeGuard/actions/workflows/ci.yml)

**AI-powered repository governance platform.**
```

### 3. `pyproject.toml` — modify

Register the 'integration' pytest marker in pyproject.toml so tests requiring external services can be filtered out in CI with -m 'not integration'.

**Before:**
```toml
[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
```

**After:**
```toml
[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
markers = [
    "integration: tests requiring external services (database, cache, etc.)",
]
```

### 4. `tests/conftest.py` — modify

Add 'import os' to existing imports for sandbox detection, then add pytest_configure hook to register the 'integration' marker and a session-scoped is_sandbox fixture.

**Before:**
```py
from uuid import UUID

import pytest
from fastapi.testclient import TestClient

from app.auth import create_token
from app.main import app
```

**After:**
```py
import os
from uuid import UUID

import pytest
from fastapi.testclient import TestClient

from app.auth import create_token
from app.main import app


# ---------------------------------------------------------------------------
# Marker registration & sandbox detection
# ---------------------------------------------------------------------------


def pytest_configure(config):
    """Register custom markers.

    Tests that need real external services (database, Redis, etc.) should be
    decorated with ``@pytest.mark.integration``.  In CI / sandbox environments
    run pytest with ``-m 'not integration'`` to skip them automatically.
    """
    config.addinivalue_line(
        "markers",
        "integration: tests requiring external services (database, cache, etc.)",
    )


@pytest.fixture(scope="session")
def is_sandbox():
    """Return *True* when running inside the Forge sandbox / CI."""
    return os.getenv("FORGE_SANDBOX") == "1"
```

### 5. `pyproject.toml` — modify

Add extend-exclude to [tool.ruff] to skip alembic migration files and Vite build artifacts from linting

**Before:**
```toml
[tool.ruff]
line-length = 120
target-version = "py312"

[tool.ruff.lint]
```

**After:**
```toml
[tool.ruff]
line-length = 120
target-version = "py312"
extend-exclude = ["db/alembic/versions", ".vite"]

[tool.ruff.lint]
```

### 6. `pyproject.toml` — modify

Add [tool.ruff.format] section to configure formatter quote style and indent style

**Before:**
```toml
[tool.ruff.lint.isort]
known-first-party = ["app", "forge_ide"]

# ── Mypy ─────────────────────────────────────────────────────────────────
```

**After:**
```toml
[tool.ruff.lint.isort]
known-first-party = ["app", "forge_ide"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"

# ── Mypy ─────────────────────────────────────────────────────────────────
```

### 7. `Forge/scripts/run_tests.ps1` — modify

Add ruff check step before compileall in the Python backend test phase to enforce linting in the test runner

**Before:**
```ps1
        $py = Resolve-Python -root $root -venvPath $forge.backend.venv_path
        $runtimePath = $py
        Info "Python: $py"

        # Static: compileall
```

**After:**
```ps1
        $py = Resolve-Python -root $root -venvPath $forge.backend.venv_path
        $runtimePath = $py
        Info "Python: $py"

        # Static: ruff lint
        $ruffOutLines = & $py -m ruff check . 2>&1
        $exitCodes["ruff"] = $LASTEXITCODE
        $outputCaptures["ruff"] = $ruffOutLines
        if ($LASTEXITCODE -eq 0) { Info "ruff check: ok" } else { Err "ruff check failed ($LASTEXITCODE)" }

        # Static: compileall
```

### 8. `.github/workflows/test.yml` — create

Create GitHub Actions CI workflow that runs Ruff linting/format checks and pytest on every push and pull request

**After:**
```yml
name: Test

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  lint:
    name: Ruff lint & format
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install Ruff
        run: pip install ruff>=0.9.0

      - name: Ruff check
        run: ruff check .

      - name: Ruff format check
        run: ruff format --check .

  test:
    name: Pytest
    runs-on: ubuntu-latest
    needs: lint
    env:
      CI: "1"
      TESTING: "1"
      DATABASE_URL: "sqlite:///:memory:"
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Run tests
        run: python -m pytest tests/ -q

```

### 9. `README.md` — modify

Add a dedicated 'Code Quality' section between Testing and Security documenting Ruff usage and commands

**Before:**
```md
ruff format --check .
mypy app/ --ignore-missing-imports
```

---

## Security
```

**After:**
```md
ruff format --check .
mypy app/ --ignore-missing-imports
```

---

## Code Quality

This project uses [Ruff](https://docs.astral.sh/ruff/) for linting and formatting, configured in `pyproject.toml`.

```powershell
ruff check .              # Lint (report violations)
ruff check . --fix        # Lint + auto-fix
ruff format .             # Format all Python files
ruff format --check .     # Check formatting (CI mode)
```

Pre-commit hooks enforce Ruff on every commit. Install with `pre-commit install`.

---

## Security
```

### 10. `forge_ide/agent.py` — modify

Remove unused `field` import (F401), move `AsyncIterator` and `Callable` to `collections.abc` (UP035), and remove unused `Any` re-import path — Ruff auto-fix for modern Python 3.12+ style.

**Before:**
```py
import asyncio
import json
import logging
import time
from dataclasses import dataclass, field
from typing import Any, AsyncIterator, Callable
```

**After:**
```py
import asyncio
import json
import logging
import time
from collections.abc import AsyncIterator, Callable
from dataclasses import dataclass
from typing import Any
```

### 11. `app/middleware/exception_handler.py` — create

Create global exception handler module that catches all exceptions, logs full stack traces server-side, and returns structured JSON error responses. Includes handlers for Exception, HTTPException, RequestValidationError, ForgeError, and ValueError.

**After:**
```py
"""Global exception handlers for the FastAPI application.

Catches all unhandled exceptions, logs full stack traces server-side,
and returns structured JSON error responses to clients.  Stack traces
are **never** leaked to the client.
"""

import logging
import uuid

from fastapi import FastAPI, Request, status
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse
from starlette.exceptions import HTTPException as StarletteHTTPException

from app.errors import ForgeError, format_error_response

logger = logging.getLogger(__name__)


def _get_request_id(request: Request) -> str:
    """Extract the request ID injected by :class:`RequestIDMiddleware`.

    Falls back to a freshly generated UUID-4 if the middleware has not
    run (e.g. during unit tests with a bare ``FastAPI()`` app).
    """
    return getattr(request.state, "request_id", None) or str(uuid.uuid4())


# ------------------------------------------------------------------
# Individual exception handlers
# ------------------------------------------------------------------

async def global_exception_handler(
    request: Request, exc: Exception
) -> JSONResponse:
    """Catch-all for any unhandled exception — returns 500."""
    request_id = _get_request_id(request)
    logger.error(
        "Unhandled exception on %s %s [request_id=%s]",
        request.method,
        request.url.path,
        request_id,
        exc_info=exc,
    )
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content=format_error_response(
            error="Internal Server Error",
            detail="Internal server error",
            request_id=request_id,
        ),
    )


async def http_exception_handler(
    request: Request, exc: StarletteHTTPException
) -> JSONResponse:
    """Handle Starlette/FastAPI ``HTTPException`` — preserves status code."""
    request_id = _get_request_id(request)
    logger.warning(
        "HTTP %s on %s %s [reques…
```

### 12. `app/middleware/__init__.py` — modify

Export setup_exception_handlers from the exception_handler sub-module so it is importable via 'from app.middleware import setup_exception_handlers'

**Before:**
```py
"""Request-ID middleware — assigns a unique ID to every HTTP request.

Implemented as a pure ASGI middleware (not BaseHTTPMiddleware) so it
cannot interfere with WebSocket connections.
"""

import uuid
from typing import Any, Callable

from starlette.types import ASGIApp, Receive, Scope, Send
```

**After:**
```py
"""Middleware package for ForgeGuard.

Exports
-------
* :class:`RequestIDMiddleware` — assigns a unique ID to every HTTP request.
* :func:`setup_exception_handlers` — registers global exception handlers.
"""

import uuid
from typing import Any, Callable

from starlette.types import ASGIApp, Receive, Scope, Send

from .exception_handler import setup_exception_handlers  # noqa: F401
```

### 13. `app/main.py` — modify

Import setup_exception_handlers and replace inline exception handler definitions with a single setup call

**Before:**
```py
from app.errors import ForgeError
from app.middleware import RequestIDMiddleware
from app.repos.db import close_pool, get_pool
```

**After:**
```py
from app.errors import ForgeError
from app.middleware import RequestIDMiddleware
from app.middleware.exception_handler import setup_exception_handlers
from app.repos.db import close_pool, get_pool
```

### 14. `tests/test_exception_handler.py` — create

Unit tests for global exception handlers using an isolated FastAPI app with inline routes (no DB or external services)

**After:**
```py
"""Unit tests for the global exception handler middleware.

All tests use a standalone FastAPI app with inline routes so that
no database connections, external services, or real routers are needed.
"""

import logging
from unittest.mock import patch

import pytest
from fastapi import FastAPI, HTTPException, Request
from fastapi.testclient import TestClient
from pydantic import BaseModel

from app.middleware.exception_handler import setup_exception_handlers
from app.errors import NotFoundError


@pytest.fixture()
def test_app() -> FastAPI:
    """Create a minimal FastAPI app with exception handlers registered."""
    app = FastAPI()
    setup_exception_handlers(app)

    @app.get("/raise-unhandled")
    async def _raise_unhandled() -> None:
        raise RuntimeError("something went very wrong")

    @app.get("/raise-http-404")
    async def _raise_http_404() -> None:
        raise HTTPException(status_code=404, detail="Item not found")

    @app.get("/raise-http-403")
    async def _raise_http_403() -> None:
        raise HTTPException(status_code=403, detail="Forbidden")

    class Item(BaseModel):
        name: str
        price: float

    @app.post("/validate")
    async def _validate(item: Item) -> dict:
        return item.model_dump()

    @app.get("/raise-value-error-not-found")
    async def _raise_value_not_found() -> None:
        raise ValueError("Widget not found")

    @app.get("/raise-value-error-bad")
    async def _raise_value_bad() -> None:
        raise ValueError("Invalid widget ID")

    @app.get("/raise-forge-not-found")
    async def _raise_forge_not_found() -> None:
        raise NotFoundError("Project not found")

    @app.get("/ok")
    async def _ok() -> dict:
        return {"status": "ok"}

    return app


@pytest.fixture()
def client(test_app: FastAPI) -> TestClient:
    return TestClient(test_app, raise_server_exceptions=False)


# ------------------------------------------------------------------
# Generic unhandled exception → 500
#…
```

### 15. `tests/test_health.py` — modify

Add a test verifying that a nonexistent route returns a structured JSON error response (not HTML) now that the global exception handler is active

**Before:**
```py
def test_request_id_header_echoed():
    """Client-supplied X-Request-ID is echoed back."""
    custom_id = "my-trace-123"
    response = client.get("/health", headers={"X-Request-ID": custom_id})
    assert response.headers["X-Request-ID"] == custom_id
```

**After:**
```py
def test_request_id_header_echoed():
    """Client-supplied X-Request-ID is echoed back."""
    custom_id = "my-trace-123"
    response = client.get("/health", headers={"X-Request-ID": custom_id})
    assert response.headers["X-Request-ID"] == custom_id


def test_nonexistent_route_returns_json_error():
    """A request to an unknown path returns structured JSON, not HTML."""
    response = client.get("/nonexistent-route-that-does-not-exist")
    assert response.status_code == 404
    data = response.json()
    assert "error" in data
    assert "request_id" in data
```
