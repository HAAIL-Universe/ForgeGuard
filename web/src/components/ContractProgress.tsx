/**
 * ContractProgress -- live step-by-step contract generation progress panel.
 *
 * Shows each contract being generated with status indicators, a running log,
 * context window meter, and cumulative token usage from the questionnaire.
 */
import { useState, useEffect, useRef, useCallback } from 'react';
import { useAuth } from '../context/AuthContext';
import { useWebSocket } from '../hooks/useWebSocket';

const API_BASE = import.meta.env.VITE_API_URL ?? '';

/* ------------------------------------------------------------------ */
/*  Helpers                                                           */
/* ------------------------------------------------------------------ */

/** Format seconds into MM:SS */
function fmtTimer(seconds: number): string {
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  return `${m}:${s.toString().padStart(2, '0')}`;
}

/* ------------------------------------------------------------------ */
/*  Contract type labels                                              */
/* ------------------------------------------------------------------ */

const CONTRACT_LABELS: Record<string, string> = {
  blueprint: 'Blueprint',
  manifesto: 'Manifesto',
  stack: 'Stack',
  schema: 'Schema',
  physics: 'Physics',
  boundaries: 'Boundaries',
  phases: 'Phases',
  ui: 'UI',
  builder_directive: 'Builder Directive',
};

const ALL_CONTRACTS = Object.keys(CONTRACT_LABELS);

/* Template contracts: generated by Python functions (no LLM call, 0 tokens).
 * They still emit WS events and are tracked internally, but hidden from the
 * visible step list so the UI doesn't show them as "failed" with 0 tokens. */
const TEMPLATE_CONTRACTS = new Set(['stack', 'boundaries', 'builder_directive']);
const LLM_CONTRACTS = ALL_CONTRACTS.filter((ct) => !TEMPLATE_CONTRACTS.has(ct));

/* ------------------------------------------------------------------ */
/*  Context window constants                                          */
/* ------------------------------------------------------------------ */

const MODEL_CONTEXT_WINDOWS: Record<string, number> = {
  'claude-haiku-4-5': 200_000,
  'claude-sonnet-4-5': 200_000,
  'claude-opus-4-6': 200_000,
  'gpt-4o': 128_000,
};
const DEFAULT_CONTEXT_WINDOW = 200_000;

/* ------------------------------------------------------------------ */
/*  Types                                                             */
/* ------------------------------------------------------------------ */

interface TokenUsage {
  input_tokens: number;
  output_tokens: number;
}

type ContractStatus = 'pending' | 'generating' | 'done';

interface LogEntry {
  time: string;
  message: string;
}

interface Props {
  projectId: string;
  tokenUsage: TokenUsage;
  model: string;
  onComplete: () => void;
  /** Contracts already completed — skip POST, just listen to WS */
  initialDone?: string[];
  /** Mini builds skip phases contract */
  buildMode?: 'mini' | 'full';
}

/* ------------------------------------------------------------------ */
/*  Styles                                                            */
/* ------------------------------------------------------------------ */

const panelStyle: React.CSSProperties = {
  display: 'flex',
  flexDirection: 'column',
  gap: '12px',
  padding: '16px 20px',
  flex: 1,
  overflowY: 'auto',
};

const stepRowStyle: React.CSSProperties = {
  display: 'flex',
  alignItems: 'center',
  gap: '10px',
  fontSize: '0.82rem',
  padding: '6px 0',
  borderBottom: '1px solid #1E293B',
};

const logPanelStyle: React.CSSProperties = {
  background: '#0F172A',
  borderRadius: '6px',
  padding: '10px 12px',
  fontFamily: 'monospace',
  fontSize: '0.72rem',
  color: '#94A3B8',
  maxHeight: '120px',
  overflowY: 'auto',
  lineHeight: '1.6',
};

const meterBarOuter: React.CSSProperties = {
  flex: 1,
  height: '8px',
  background: '#1E293B',
  borderRadius: '4px',
  overflow: 'hidden',
};

/* ------------------------------------------------------------------ */
/*  Component                                                         */
/* ------------------------------------------------------------------ */

export default function ContractProgress({ projectId, tokenUsage: initialTokenUsage, model, onComplete, initialDone, buildMode = 'full' }: Props) {
  const { token } = useAuth();
  // Mini builds skip phases contract
  const visibleContracts = buildMode === 'mini' ? LLM_CONTRACTS.filter((c) => c !== 'phases') : LLM_CONTRACTS;
  const reconnecting = !!(initialDone && initialDone.length > 0);
  const [statuses, setStatuses] = useState<Record<string, ContractStatus>>(() =>
    Object.fromEntries(ALL_CONTRACTS.map((c) => [
      c,
      // Mini builds skip phases — mark as done so it doesn't block completion
      initialDone?.includes(c) ? 'done' as const
        : (buildMode === 'mini' && c === 'phases') ? 'done' as const
        : 'pending' as const,
    ])),
  );
  const [log, setLog] = useState<LogEntry[]>(() =>
    reconnecting ? [{ time: new Date().toLocaleTimeString('en-GB', { hour12: false }), message: `Reconnected — ${initialDone!.length} of ${ALL_CONTRACTS.length} already complete` }] : [],
  );
  const [generating, setGenerating] = useState(false);
  const [allDone, setAllDone] = useState(false);
  const [cancelled, setCancelled] = useState(false);
  const [cancelling, setCancelling] = useState(false);
  const [cumulativeTokens, setCumulativeTokens] = useState<TokenUsage>(initialTokenUsage);
  const [liveTokens, setLiveTokens] = useState<Record<string, { input: number; output: number }>>({});
  const [contractTimers, setContractTimers] = useState<Record<string, { startedAt: number; frozenElapsed: number | null }>>({});
  const [tick, setTick] = useState(0);
  const logEndRef = useRef<HTMLDivElement>(null);
  const startedRef = useRef(false);
  const abortRef = useRef<AbortController | null>(null);
  const genStartedAtRef = useRef<number | null>(null);

  const addLog = useCallback((msg: string) => {
    const now = new Date();
    const time = now.toLocaleTimeString('en-GB', { hour12: false });
    setLog((prev) => [...prev, { time, message: msg }]);
  }, []);

  /* 1-second tick for live timers */
  useEffect(() => {
    const id = setInterval(() => setTick((t) => t + 1), 1000);
    return () => clearInterval(id);
  }, []);

  /* Auto-scroll log */
  useEffect(() => {
    logEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [log]);

  /* Handle WS progress messages */
  useWebSocket(
    useCallback(
      (data: { type: string; payload: any }) => {
        if (data.type !== 'contract_progress') return;
        const p = data.payload;
        if (p.project_id !== projectId) return;

        const label = CONTRACT_LABELS[p.contract_type] ?? p.contract_type;
        if (p.status === 'generating') {
          setStatuses((prev) => ({ ...prev, [p.contract_type]: 'generating' }));
          setLiveTokens((prev) => ({ ...prev, [p.contract_type]: { input: 0, output: 0 } }));
          setContractTimers((prev) => ({ ...prev, [p.contract_type]: { startedAt: Date.now(), frozenElapsed: null } }));
          if (!genStartedAtRef.current) genStartedAtRef.current = Date.now();
          if (!TEMPLATE_CONTRACTS.has(p.contract_type)) addLog(`Generating ${label}...`);
        } else if (p.status === 'streaming') {
          /* Live token progress from streamed LLM response */
          setLiveTokens((prev) => ({
            ...prev,
            [p.contract_type]: {
              input: p.input_tokens ?? 0,
              output: p.output_tokens ?? 0,
            },
          }));
        } else if (p.status === 'cancelled') {
          addLog(`✗ Generation cancelled at ${label}`);
          setCancelled(true);
          setGenerating(false);
        } else if (p.status === 'done') {
          setStatuses((prev) => ({ ...prev, [p.contract_type]: 'done' }));
          const inTok = p.input_tokens ?? 0;
          const outTok = p.output_tokens ?? 0;
          const elapsed = p.elapsed_s ?? null;
          /* Freeze the timer to the server-reported elapsed */
          setContractTimers((prev) => ({
            ...prev,
            [p.contract_type]: {
              startedAt: prev[p.contract_type]?.startedAt ?? Date.now(),
              frozenElapsed: elapsed,
            },
          }));
          const elapsedStr = elapsed != null ? ` — ${fmtTimer(elapsed)}` : '';
          if (!TEMPLATE_CONTRACTS.has(p.contract_type)) {
            addLog(`✓ ${label} complete (${inTok.toLocaleString()} in / ${outTok.toLocaleString()} out${elapsedStr})`);
          }

          /* Clear live tokens for this contract */
          setLiveTokens((prev) => {
            const next = { ...prev };
            delete next[p.contract_type];
            return next;
          });

          /* Accumulate token usage */
          if (inTok || outTok) {
            setCumulativeTokens((prev) => ({
              input_tokens: prev.input_tokens + inTok,
              output_tokens: prev.output_tokens + outTok,
            }));
          }

          /* Check if all done */
          setStatuses((prev) => {
            const values = Object.values(prev);
            if (values.every((s) => s === 'done')) {
              setAllDone(true);
              addLog('All contracts generated successfully.');
            }
            return prev;
          });
        }
      },
      [projectId, addLog],
    ),
  );

  /* Kick off generation on mount (skip if reconnecting to in-progress generation) */
  useEffect(() => {
    if (startedRef.current) return;
    startedRef.current = true;

    if (reconnecting) {
      /* Check if everything is already done */
      if (initialDone && initialDone.length >= ALL_CONTRACTS.length) {
        setAllDone(true);
        setGenerating(false);
        addLog('All contracts generated successfully.');
      } else {
        setGenerating(true);
      }
      return; // Just listen to WS — don't fire a new POST
    }

    setGenerating(true);
    addLog('Starting contract generation...');

    const controller = new AbortController();
    abortRef.current = controller;

    fetch(`${API_BASE}/projects/${projectId}/contracts/generate`, {
      method: 'POST',
      headers: { Authorization: `Bearer ${token}` },
      signal: controller.signal,
    })
      .then(async (res) => {
        if (!res.ok) throw new Error('Generation failed');
        const body = await res.json();
        if (body.cancelled) {
          /* Server confirmed cancellation — WS event already handled UI */
          setCancelled(true);
          setGenerating(false);
          return;
        }
        /* Mark any remaining as done (safety net) */
        setStatuses((prev) => {
          const updated = { ...prev };
          for (const key of ALL_CONTRACTS) {
            if (updated[key] !== 'done') updated[key] = 'done';
          }
          return updated;
        });
        setAllDone(true);
        setGenerating(false);
      })
      .catch((err) => {
        if (err?.name === 'AbortError') return; // unmount — ignore
        /* Only show error if not already in cancelled state */
        setCancelled((prev) => {
          if (!prev) addLog('✗ Contract generation failed');
          return prev;
        });
        setGenerating(false);
      });

    return () => { controller.abort(); };
  }, [projectId, token, addLog]);

  /* Derived values */
  const contextWindow = MODEL_CONTEXT_WINDOWS[model] ?? DEFAULT_CONTEXT_WINDOW;
  /* Include live streaming tokens in the running total */
  const liveTotal = Object.values(liveTokens).reduce(
    (acc, t) => ({ input: acc.input + t.input, output: acc.output + t.output }),
    { input: 0, output: 0 },
  );
  const runningInput = cumulativeTokens.input_tokens + liveTotal.input;
  const runningOutput = cumulativeTokens.output_tokens + liveTotal.output;
  const totalTokens = runningInput + runningOutput;
  const ctxPercent = Math.min(100, (totalTokens / contextWindow) * 100);
  const doneCount = Object.values(statuses).filter((s) => s === 'done').length;
  const llmDoneCount = visibleContracts.filter((ct) => statuses[ct] === 'done').length;

  /* Timer computations */
  const totalElapsedS = (() => {
    if (!genStartedAtRef.current) return 0;
    /* Sum of frozen timers + live timers */
    let total = 0;
    for (const ct of ALL_CONTRACTS) {
      const t = contractTimers[ct];
      if (!t) continue;
      if (t.frozenElapsed != null) {
        total += t.frozenElapsed;
      } else {
        total += (Date.now() - t.startedAt) / 1000;
      }
    }
    return total;
  })();
  const wallElapsedS = genStartedAtRef.current ? (Date.now() - genStartedAtRef.current) / 1000 : 0;
  void tick; /* ensure tick triggers re-render */

  /* Color for context bar */
  const ctxColor = ctxPercent > 80 ? '#EF4444' : ctxPercent > 50 ? '#F59E0B' : '#22C55E';

  return (
    <div style={panelStyle} data-testid="contract-progress">
      {/* Header */}
      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
        <h4 style={{ margin: 0, fontSize: '0.9rem', color: '#F8FAFC' }}>
          {allDone ? '✓ Contracts Ready' : `Generating Contracts… (${llmDoneCount}/${visibleContracts.length})`}
        </h4>
        {(generating || allDone) && genStartedAtRef.current && (
          <span style={{ fontSize: '0.75rem', fontFamily: 'monospace', color: allDone ? '#22C55E' : '#94A3B8' }}>
            ⏱ {fmtTimer(wallElapsedS)}
          </span>
        )}
      </div>

      {/* Context window meter */}
      <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#94A3B8' }}>
          <span>Context Window ({model})</span>
          <span>
            {totalTokens.toLocaleString()} / {contextWindow.toLocaleString()} tokens ({ctxPercent.toFixed(1)}%)
          </span>
        </div>
        <div style={meterBarOuter}>
          <div
            style={{
              width: `${ctxPercent}%`,
              height: '100%',
              background: ctxColor,
              borderRadius: '4px',
              transition: 'width 0.4s ease',
            }}
          />
        </div>
        <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.65rem', color: '#64748B' }}>
          <span>Input: {runningInput.toLocaleString()}</span>
          <span>Output: {runningOutput.toLocaleString()}</span>
        </div>
      </div>

      {/* Step list */}
      <div>
        {visibleContracts.map((ct) => {
          const st = statuses[ct];
          const icon = st === 'done' ? '✅' : st === 'generating' ? '⏳' : '○';
          const color = st === 'done' ? '#22C55E' : st === 'generating' ? '#F59E0B' : '#475569';
          const live = liveTokens[ct];
          const timer = contractTimers[ct];
          const timerStr = timer
            ? timer.frozenElapsed != null
              ? fmtTimer(timer.frozenElapsed)
              : fmtTimer((Date.now() - timer.startedAt) / 1000)
            : null;
          return (
            <div key={ct} style={stepRowStyle}>
              <span style={{ width: '20px', textAlign: 'center' }}>{icon}</span>
              <span style={{ flex: 1, color }}>{CONTRACT_LABELS[ct]}</span>
              {timerStr && (
                <span style={{
                  fontSize: '0.7rem',
                  fontFamily: 'monospace',
                  color: st === 'done' ? '#22C55E' : '#F59E0B',
                  minWidth: '38px',
                  textAlign: 'right',
                }}>
                  {timerStr}
                </span>
              )}
              {st === 'generating' && live ? (
                <span style={{ fontSize: '0.7rem', color: '#94A3B8', fontFamily: 'monospace', display: 'flex', gap: '8px' }}>
                  <span style={{ color: '#60A5FA' }}>↓{live.input.toLocaleString()}</span>
                  <span style={{ color: '#34D399' }}>↑{live.output.toLocaleString()}</span>
                </span>
              ) : (
                <span style={{ fontSize: '0.7rem', color: '#64748B', textTransform: 'uppercase' }}>{st}</span>
              )}
            </div>
          );
        })}
      </div>

      {/* Log panel */}
      <div style={logPanelStyle} data-testid="contract-log">
        {log.map((entry, i) => (
          <div key={i}>
            <span style={{ color: '#475569' }}>{entry.time}</span>{' '}
            {entry.message}
          </div>
        ))}
        <div ref={logEndRef} />
      </div>

      {/* Done button */}
      {allDone && (
        <button
          onClick={onComplete}
          data-testid="contracts-done-btn"
          style={{
            background: '#16A34A',
            color: '#fff',
            border: 'none',
            borderRadius: '8px',
            padding: '10px 20px',
            cursor: 'pointer',
            fontSize: '0.8rem',
            fontWeight: 600,
            alignSelf: 'center',
          }}
        >
          Done — View Contracts
        </button>
      )}

      {generating && !allDone && (
        <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '8px' }}>
          <p style={{ textAlign: 'center', color: '#64748B', fontSize: '0.75rem', margin: 0 }}>
            Generating…
          </p>
          <button
            onClick={async () => {
              setCancelling(true);
              try {
                const res = await fetch(`${API_BASE}/projects/${projectId}/contracts/cancel`, {
                  method: 'POST',
                  headers: { Authorization: `Bearer ${token}` },
                });
                if (!res.ok) {
                  /* No active generation — it already finished or was cancelled */
                  /* Check if all contracts are done */
                  setStatuses((prev) => {
                    const values = Object.values(prev);
                    if (values.every((s) => s === 'done')) {
                      setAllDone(true);
                      addLog('All contracts generated successfully.');
                    } else {
                      addLog('Generation already finished.');
                      setCancelled(true);
                    }
                    return prev;
                  });
                  setGenerating(false);
                }
              } catch {
                /* WS event will confirm cancellation */
              }
            }}
            disabled={cancelling}
            data-testid="cancel-generation-btn"
            style={{
              background: 'transparent',
              color: cancelling ? '#475569' : '#EF4444',
              border: `1px solid ${cancelling ? '#334155' : '#EF4444'}`,
              borderRadius: '6px',
              padding: '6px 16px',
              cursor: cancelling ? 'not-allowed' : 'pointer',
              fontSize: '0.75rem',
              fontWeight: 500,
              opacity: cancelling ? 0.6 : 1,
            }}
          >
            {cancelling ? 'Cancelling…' : 'Cancel Generation'}
          </button>
        </div>
      )}

      {cancelled && !allDone && (
        <div style={{ textAlign: 'center' }}>
          <p style={{ color: '#F59E0B', fontSize: '0.8rem', margin: '0 0 8px' }}>
            Generation cancelled — {visibleContracts.filter((ct) => statuses[ct] === 'done').length} of {visibleContracts.length} contracts were generated.
          </p>
          <button
            onClick={onComplete}
            data-testid="contracts-cancelled-btn"
            style={{
              background: '#334155',
              color: '#F8FAFC',
              border: 'none',
              borderRadius: '8px',
              padding: '10px 20px',
              cursor: 'pointer',
              fontSize: '0.8rem',
              fontWeight: 600,
            }}
          >
            View Contracts
          </button>
        </div>
      )}
    </div>
  );
}
